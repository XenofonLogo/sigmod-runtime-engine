* # 📖 Εργασία: Ανάπτυξη Λογισμικού για Πληροφοριακά Συστήματα (1ο Μέρος)

[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/gjaw_qSU)

[![Build Status](https://github.com/uoa-k23a/k23a-2025-d1-runtimeerror/actions/workflows/software_tester.yml/badge.svg)](https://github.com/uoa-k23a/k23a-2025-d1-runtimeerror/actions/workflows/software_tester.yml)

## 👥 Μέλη Ομάδας

* **Ξενοφών Λογοθέτης** - sdi2100087@di.uoa.gr - `1115202100087`
* **Σακκέτος Γεώργιος** - sdi2000177@di.uoa.gr - `1115202000177`
* **Φωτιάδης Ευάγγελος** - sdi1900301@di.uoa.gr - `1115201900301`

---

## Εκτέλεση

##### Οι αρχική υλοποίηση που τρέχει σαν default

```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DEXECUTE_IMPL=default -Wno-dev
cmake --build build -- -j $(nproc) fast
```

ή

```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -Wno-dev
cmake --build build -- -j $(nproc) fast
```

##### Οι τρείς υλοποιήσεις

```bash
# Για την 'robinhood'
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DEXECUTE_IMPL=robinhood -Wno-dev
cmake --build build -- -j $(nproc) fast

# Για την 'hopscotch'
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DEXECUTE_IMPL=hopscotch -Wno-dev
cmake --build build -- -j $(nproc) fast

# Για την 'cuckoo'
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DEXECUTE_IMPL=cuckoo -Wno-dev
cmake --build build -- -j $(nproc) fast
```

> ***Σημείωση:*** Το υπόλοιπο της εκτέλεσης είναι ίδιο

---

## 1. Αλγόριθμος Κατακερματισμού Robin Hood

* **Υλοποιήθηκε από:** **Φωτιάδης Ευάγγελος**

Ο αλγόριθμος του hash join τροποποιήθηκε ώστε να χρησιμοποιεί μια προσαρμοσμένη δομή hashtable βασισμένη στο Robin-Hood hashing. Η προσέγγιση αυτή μειώνει το κόστος αναζήτησης κατά την φάση probe και προσφέρει πιο σταθερή απόδοση, ειδικά σε περιπτώσεις όπου υπάρχουν πολλά collisions.

1. Υλοποίηση Robin-Hood Hash Table
   Αντί για ένα unordered_map, υλοποιήθηκε ένα hashtable από το μηδέν, όπου κάθε bucket αποθηκεύει:

* το key,
* το “probe sequence length” (psl) και
* μία λίστα από row indices (ώστε να υποστηρίζονται πολλαπλά αντίστοιχα κλειδιά).

Κατά την εισαγωγή νέου στοιχείου, αν ένα bucket έχει μικρότερο psl από το στοιχείο που επιχειρεί να εισαχθεί, γίνεται ανταλλαγή (swap). Με αυτόν τον τρόπο, τα στοιχεία που βρίσκονται “μακριά” από τη θέση που τους αντιστοιχεί βάσει hash μετακινούνται πιο μπροστά, μειώνοντας το κόστος των επόμενων αναζητήσεων.
Κύρια οφέλη:

* μικρότερη μέση διάρκεια probing,
* λιγότερα cache misses,
* ομαλή υποστήριξη duplicate keys (κάθε bucket διατηρεί λίστα με indices).

2. Συνάρτηση try_normalize

Προστέθηκε η βοηθητική συνάρτηση try_normalize, η οποία επιχειρεί να μετατρέψει το raw key από τον πίνακα (που βρίσκεται μέσα σε std::variant) στον επιθυμητό τύπο T. Χρησιμοποιεί std::optional και επιστρέφει nullopt αν η μετατροπή δεν είναι εφικτή.

Καλύπτει τις εξής περιπτώσεις:

* αριθμητικοί τύποι προς αριθμητικό T,
* αριθμοί προς std::string όταν το join key είναι VARCHAR,
* ίδιος τύπος T,
* παράβλεψη std::monostate (NULL τιμές).

Στόχος ήταν η αποφυγή exceptions και η υποστήριξη ετερογενών δεδομένων χωρίς να διακόπτεται η εκτέλεση.

3. Κατάργηση Exceptions για Type Mismatch

Στην παλαιότερη υλοποίηση, οποιαδήποτε ασυμβατότητα τύπου οδηγούσε σε runtime_error. Πλέον, τέτοιες τιμές απλώς αγνοούνται χωρίς να διακόπτεται ο αλγόριθμος. Αυτή η αλλαγή κάνει τον join αλγόριθμο πιο ανθεκτικό σε ελλιπή ή μεικτά δεδομένα.

4. Βελτιώσεις στη Φάση Build και Probe
   Η λογική του join (build και probe) παρέμεινε ίδια ως προς το αποτέλεσμα, αλλά αναδιαμορφώθηκε:

* Στη φάση build εισάγονται μόνο έγκυρα keys (μετά από try_normalize).
* Αν το ίδιο key συναντηθεί ξανά, το row index προστίθεται στο υπάρχον bucket.
  Η φάση probe σταματά αυτόματα όταν:
* βρεθεί άδειο bucket, ή
* το bucket που εξετάζεται έχει μικρότερο psl από τον τρέχοντα μετρητή probing, σύμφωνα με την λογική Robin-Hood.
  Δεν έγινε καμία αλλαγή στην παραγωγή των αποτελεσμάτων του join.

5. Αποτελέσματα Απόδοσης

> **Συνολικός χρόνος εκτέλεσης των queries:** `517832 ms`
> (Προηγούμενος χρόνος: `493646 ms`)

---

## 2. Αλγόριθμος Κατακερματισμού Hopscotch

* **Υλοποιήθηκε από:** **Ξενοφών Λογοθέτης**

### 2.1. Αντικατάσταση `std::unordered_map` με `tsl::hopscotch_map`

Η βασική αλλαγή αφορά τη δομή του hash table που χρησιμοποιείται στον αλγόριθμο join. Αντί για `std::unordered_map`, χρησιμοποιείται πλέον η `tsl::hopscotch_map`.

### 2.2. Προσθήκη Βοηθητικής Συνάρτησης `try_normalize`

Προστέθηκε η `inline` συνάρτηση `try_normalize`, η οποία επιχειρεί να "ομαλοποιήσει" το κλειδί (join key) σε ενιαίο τύπο `T`.

**Λειτουργία:**

* Επιστρέφει `std::optional<T>`, το οποίο είναι `nullopt` αν το key δεν μπορεί να μετατραπεί με ασφάλεια.
* Υποστηρίζει:
  * Μετατροπή αριθμητικών τύπων (int, double).
  * Μετατροπή αριθμών σε string (αν ο join key είναι VARCHAR).
  * Αγνόηση `std::monostate` (NULL τιμές).

**Στόχος:**

* Αποφυγή exceptions κατά τη σύγκριση διαφορετικών τύπων.
* Καλύτερη ανθεκτικότητα σε heterogenous data sets.
* Επέκταση συμβατότητας join πεδίων διαφορετικού τύπου.

### 2.3. Αφαίρεση Ρίψης Exceptions για Type Mismatch

Στην αρχική έκδοση, κάθε ασυμβατότητα τύπου προκαλούσε `throw std::runtime_error("wrong type of field")`.

**Πλέον:**

* Οι ασύμβατες ή null τιμές αγνοούνται απλά.
* Το join συνεχίζει κανονικά χωρίς διακοπή.
* Αυτό βελτιώνει τη σταθερότητα σε mixed ή ελλιπή δεδομένα.

### 2.4. Βελτιώσεις στη Φάση Build / Probe

Η βασική λογική παρέμεινε ίδια, αλλά:

* Οι φάσεις build και probe χρησιμοποιούν τη συνάρτηση `try_normalize`.
* Τα κλειδιά αποθηκεύονται μόνο αν έχουν έγκυρη τιμή (όχι `monostate`).
* Ελαχιστοποιήθηκε ο επαναλαμβανόμενος κώδικας και ο έλεγχος τύπων.

> **Σημείωση:** Καμία αλλαγή δεν έγινε στη λογική του Join ή στα δεδομένα εξόδου.

### 2.5. Απόδοση

> **Συνολικός χρόνος εκτέλεσης των queries:** `737201 ms`
> (Προηγούμενος χρόνος: `493646 ms`)

---

## 3. Αλγόριθμος Κατακερματισμού Cuckoo

* **Υλοποιήθηκε από: Σακκέτος Γεώργιος**

### 3.1. Αντικατάσταση `std::unordered_map` με `libcuckoo::cuckoohash_map`

  Η βασική δομή `std::unordered_map` της αρχικής υλοποίησης αντικαταστάθηκε με τη `libcuckoo::cuckoohash_map` για την κατασκευή του hash table.

### 3.2. Προσθήκη Βοηθητικής Συνάρτησης `try_normalize`

  Προστέθηκε μια βοηθητική συνάρτηση `try_normalize`, η οποία επιχειρεί να "ομαλοποιήσει" (normalize) το κλειδί (join key) στον απαιτούμενο τύπο `T` του hash table.

  **Λειτουργία:**

* Επιστρέφει `std::optional<T>`, η οποία τιμή είναι `nullopt` εάν η μετατροπή του κλειδιού (join key) αποτύχει.
* Υποστηρίζει:

  * Μετατροπή μεταξύ αριθμητικών τύπων (π.χ. `int` σε `double`).
  * Μετατροπή αριθμητικών τιμών σε `string` εάν ο τύπος του κλειδού (join key) είναι `VARCHAR`.
  * Αγνόηση `std::monostate` (NULL values), επιστρέφοντας `nullopt`.

  **Στόχος:**
* Αποφυγή exceptions κατά τη σύγκριση διαφορετικών τύπων.
* Καλύτερη ανθεκτικότητα σε δεδομένα με διαφορετικούς τύπους (heterogeneous data).
* Βελτιωμένη συμβατότητα μεταξύ πεδίων join διαφορετικού τύπου.

### 3.3. Αφαίρεση Ρίψης Exceptions για Type Mismatch

  Στην αρχική έκδοση, οποιαδήποτε ασυμβατότητα τύπου (type mismatch) που δεν ήταν `std::monostate` προκαλούσε `throw std::runtime_error("wrong type of field")`.

  **Πλέον:**

* Η `try_normalize` διαχειρίζεται τις ασυμβατότητες επιστρέφοντας `nullopt`.
* Εάν ένα κλειδί είναι `std::monostate` ή δεν μπορεί να μετατραπεί, η εγγραφή αυτή απλώς αγνοείται, επιτρέποντας στο join να συνεχίσει χωρίς διακοπή.

### 3.4. Προσαρμογές στη Φάση Build / Probe

  Η λογική παραμένει ίδια, αλλά με τις εξείς αλλαγές:

* **Build Phase:** Η εισαγωγή στο hash table δεν είναι πλέον μια απλή ενέργεια. Απαιτεί τα εξής βήματα:
  1. Το κλειδί ομαλοποιείται με την `try_normalize`.
  2. Γίνεται έλεγχος με `hash_table.find()` για να δούμε αν το κλειδί υπάρχει ήδη.
  3. **Αν βρεθεί:** Ο υπάρχων `vector` ανακτάται, ενημερώνεται με το νέο index, και καλείται η `hash_table.update()` για να αντικαταστήσει την παλιά τιμή.
  4. **Αν δεν βρεθεί:** Ένας νέος `vector` δημιουργείται και καλείται η `hash_table.insert()` για τη νέα εγγραφή.
* **Probe Phase:** Χρησιμοποιεί επίσης την `try_normalize` πριν κάνει `find` στο hash table.

### 3.5. Αποτελέσματα Απόδοσης

> **Συνολικός χρόνος εκτέλεσης των queries:** `768494 ms`
> (Προηγούμενος χρόνος: `433537 ms`)
