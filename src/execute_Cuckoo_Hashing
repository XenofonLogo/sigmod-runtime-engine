#include <hardware.h>
#include <plan.h>
#include <table.h>

namespace Contest {

using ExecuteResult = std::vector<std::vector<Data>>;

ExecuteResult execute_impl(const Plan& plan, size_t node_idx);

struct JoinAlgorithm {
    bool                                             build_left;
    ExecuteResult&                                   left;
    ExecuteResult&                                   right;
    ExecuteResult&                                   results;
    size_t                                           left_col, right_col;
    const std::vector<std::tuple<size_t, DataType>>& output_attrs;

    template <class T>
    auto run() {
        namespace views = ranges::views;
        std::unordered_map<T, std::vector<size_t>> hash_table;
        if (build_left) {
            for (auto&& [idx, record]: left | views::enumerate) {
                std::visit(
                    [&hash_table, idx = idx](const auto& key) {
                        using Tk = std::decay_t<decltype(key)>;
                        if constexpr (std::is_same_v<Tk, T>) {
                            if (auto itr = hash_table.find(key); itr == hash_table.end()) {
                                hash_table.emplace(key, std::vector<size_t>(1, idx));
                            } else {
                                itr->second.push_back(idx);
                            }
                        } else if constexpr (not std::is_same_v<Tk, std::monostate>) {
                            throw std::runtime_error("wrong type of field");
                        }
                    },
                    record[left_col]);
            }
            for (auto& right_record: right) {
                std::visit(
                    [&](const auto& key) {
                        using Tk = std::decay_t<decltype(key)>;
                        if constexpr (std::is_same_v<Tk, T>) {
                            if (auto itr = hash_table.find(key); itr != hash_table.end()) {
                                for (auto left_idx: itr->second) {
                                    auto&             left_record = left[left_idx];
                                    std::vector<Data> new_record;
                                    new_record.reserve(output_attrs.size());
                                    for (auto [col_idx, _]: output_attrs) {
                                        if (col_idx < left_record.size()) {
                                            new_record.emplace_back(left_record[col_idx]);
                                        } else {
                                            new_record.emplace_back(
                                                right_record[col_idx - left_record.size()]);
                                        }
                                    }
                                    results.emplace_back(std::move(new_record));
                                }
                            }
                        } else if constexpr (not std::is_same_v<Tk, std::monostate>) {
                            throw std::runtime_error("wrong type of field");
                        }
                    },
                    right_record[right_col]);
            }
        } else {
            for (auto&& [idx, record]: right | views::enumerate) {
                std::visit(
                    [&hash_table, idx = idx](const auto& key) {
                        using Tk = std::decay_t<decltype(key)>;
                        if constexpr (std::is_same_v<Tk, T>) {
                            if (auto itr = hash_table.find(key); itr == hash_table.end()) {
                                hash_table.emplace(key, std::vector<size_t>(1, idx));
                            } else {
                                itr->second.push_back(idx);
                            }
                        } else if constexpr (not std::is_same_v<Tk, std::monostate>) {
                            throw std::runtime_error("wrong type of field");
                        }
                    },
                    record[right_col]);
            }
            for (auto& left_record: left) {
                std::visit(
                    [&](const auto& key) {
                        using Tk = std::decay_t<decltype(key)>;
                        if constexpr (std::is_same_v<Tk, T>) {
                            if (auto itr = hash_table.find(key); itr != hash_table.end()) {
                                for (auto right_idx: itr->second) {
                                    auto&             right_record = right[right_idx];
                                    std::vector<Data> new_record;
                                    new_record.reserve(output_attrs.size());
                                    for (auto [col_idx, _]: output_attrs) {
                                        if (col_idx < left_record.size()) {
                                            new_record.emplace_back(left_record[col_idx]);
                                        } else {
                                            new_record.emplace_back(
                                                right_record[col_idx - left_record.size()]);
                                        }
                                    }
                                    results.emplace_back(std::move(new_record));
                                }
                            }
                        } else if constexpr (not std::is_same_v<Tk, std::monostate>) {
                            throw std::runtime_error("wrong type of field");
                        }
                    },
                    left_record[left_col]);
            }
        }
    }
};

ExecuteResult execute_hash_join(const Plan&          plan,
    const JoinNode&                                  join,
    const std::vector<std::tuple<size_t, DataType>>& output_attrs) {
    auto                           left_idx    = join.left;
    auto                           right_idx   = join.right;
    auto&                          left_node   = plan.nodes[left_idx];
    auto&                          right_node  = plan.nodes[right_idx];
    auto&                          left_types  = left_node.output_attrs;
    auto&                          right_types = right_node.output_attrs;
    auto                           left        = execute_impl(plan, left_idx);
    auto                           right       = execute_impl(plan, right_idx);
    std::vector<std::vector<Data>> results;

    JoinAlgorithm join_algorithm{.build_left = join.build_left,
        .left                                = left,
        .right                               = right,
        .results                             = results,
        .left_col                            = join.left_attr,
        .right_col                           = join.right_attr,
        .output_attrs                        = output_attrs};
    if (join.build_left) {
        switch (std::get<1>(left_types[join.left_attr])) {
        case DataType::INT32:   join_algorithm.run<int32_t>(); break;
        case DataType::INT64:   join_algorithm.run<int64_t>(); break;
        case DataType::FP64:    join_algorithm.run<double>(); break;
        case DataType::VARCHAR: join_algorithm.run<std::string>(); break;
        }
    } else {
        switch (std::get<1>(right_types[join.right_attr])) {
        case DataType::INT32:   join_algorithm.run<int32_t>(); break;
        case DataType::INT64:   join_algorithm.run<int64_t>(); break;
        case DataType::FP64:    join_algorithm.run<double>(); break;
        case DataType::VARCHAR: join_algorithm.run<std::string>(); break;
        }
    }

    return results;
}

ExecuteResult execute_scan(const Plan&               plan,
    const ScanNode&                                  scan,
    const std::vector<std::tuple<size_t, DataType>>& output_attrs) {
    auto                           table_id = scan.base_table_id;
    auto&                          input    = plan.inputs[table_id];
    return Table::copy_scan(input, output_attrs);
}

ExecuteResult execute_impl(const Plan& plan, size_t node_idx) {
    auto& node = plan.nodes[node_idx];
    return std::visit(
        [&](const auto& value) {
            using T = std::decay_t<decltype(value)>;
            if constexpr (std::is_same_v<T, JoinNode>) {
                return execute_hash_join(plan, value, node.output_attrs);
            } else {
                return execute_scan(plan, value, node.output_attrs);
            }
        },
        node.data);
}

ColumnarTable execute(const Plan& plan, [[maybe_unused]] void* context) {
    namespace views = ranges::views;

    struct CuckooMapData {
        using V = std::vector<size_t>;

        size_t capacity = 0;
        std::vector<char> occupied;
        std::vector<Data> keys;
        std::vector<V> vals;

        CuckooMapData() = default;

        static size_t hash_data(const Data& d) {
            return std::visit(
                [](const auto& v) -> size_t {
                    using T = std::decay_t<decltype(v)>;
                    if constexpr (std::is_same_v<T, int32_t>) {
                        return std::hash<int32_t>{}(v);
                    } else if constexpr (std::is_same_v<T, int64_t>) {
                        return std::hash<int64_t>{}(v);
                    } else if constexpr (std::is_same_v<T, double>) {
                        return std::hash<double>{}(v);
                    } else if constexpr (std::is_same_v<T, std::string>) {
                        return std::hash<std::string>{}(v);
                    } else {
                        // monostate or unsupported
                        return 0;
                    }
                },
                d);
        }

        void reset(size_t cap) {
            capacity = 1;
            while (capacity < cap) capacity <<= 1;
            occupied.assign(capacity, 0);
            keys.assign(capacity, Data{});
            vals.clear();
            vals.resize(capacity);
        }

        size_t h1_hash(const Data& k) const { return hash_data(k) & (capacity - 1); }
        size_t h2_hash(const Data& k) const {
            auto x = hash_data(k);
            x ^= (x >> 33) ^ 0x9e3779b97f4a7c15ULL;
            return x & (capacity - 1);
        }

        V* find(const Data& k) {
            size_t p1 = h1_hash(k);
            if (occupied[p1] && keys[p1] == k) return &vals[p1];
            size_t p2 = h2_hash(k);
            if (occupied[p2] && keys[p2] == k) return &vals[p2];
            return nullptr;
        }

        void rehash_grow() {
            std::vector<std::pair<Data, V>> entries;
            for (size_t i = 0; i < capacity; ++i) {
                if (occupied[i]) entries.emplace_back(keys[i], std::move(vals[i]));
            }
            reset(capacity * 2);
            for (auto &e: entries) {
                insert_bulk(std::move(e.first), std::move(e.second));
            }
        }

        void insert_bulk(Data&& k, V&& v) {
            size_t p1 = h1_hash(k);
            if (!occupied[p1]) {
                keys[p1] = std::move(k);
                vals[p1] = std::move(v);
                occupied[p1] = 1;
                return;
            }
            if (keys[p1] == k) {
                auto& vec = vals[p1];
                vec.insert(vec.end(), v.begin(), v.end());
                return;
            }
            size_t p2 = h2_hash(k);
            if (!occupied[p2]) {
                keys[p2] = std::move(k);
                vals[p2] = std::move(v);
                occupied[p2] = 1;
                return;
            }
            if (keys[p2] == k) {
                auto& vec = vals[p2];
                vec.insert(vec.end(), v.begin(), v.end());
                return;
            }

            Data curk = std::move(k);
            V curv = std::move(v);
            size_t pos = p1;
            const int MAX_KICKS = 512;
            for (int kick = 0; kick < MAX_KICKS; ++kick) {
                if (!occupied[pos]) {
                    keys[pos] = std::move(curk);
                    vals[pos] = std::move(curv);
                    occupied[pos] = 1;
                    return;
                }
                if (keys[pos] == curk) {
                    vals[pos].insert(vals[pos].end(), curv.begin(), curv.end());
                    return;
                }
                std::swap(keys[pos], curk);
                std::swap(vals[pos], curv);
                size_t a1 = h1_hash(curk);
                size_t a2 = h2_hash(curk);
                pos = (pos == a1) ? a2 : a1;
            }
            rehash_grow();
            insert_bulk(std::move(curk), std::move(curv));
        }

        void insert(const Data& k, size_t idx) {
            if (std::get_if<std::monostate>(&k)) {
                // treat NULL as non-joinable
                return;
            }
            if (auto p = find(k)) { p->push_back(idx); return; }
            size_t p = h1_hash(k);
            const int MAX_KICKS = 512;
            Data curk = k;
            V curv; curv.push_back(idx);
            for (int kick = 0; kick < MAX_KICKS; ++kick) {
                if (!occupied[p]) {
                    keys[p] = curk;
                    vals[p] = std::move(curv);
                    occupied[p] = 1;
                    return;
                }
                if (keys[p] == curk) {
                    vals[p].push_back(idx);
                    return;
                }
                std::swap(keys[p], curk);
                std::swap(vals[p], curv);
                size_t a1 = h1_hash(curk);
                size_t a2 = h2_hash(curk);
                p = (p == a1) ? a2 : a1;
            }
            rehash_grow();
            insert_bulk(std::move(curk), std::move(curv));
        }
    };

    // recursive evaluator using the CuckooMapData for joins
    std::function<ExecuteResult(size_t)> eval = [&](size_t node_idx) -> ExecuteResult {
        auto& node = plan.nodes[node_idx];
        return std::visit(
            [&](const auto& value) -> ExecuteResult {
                using T = std::decay_t<decltype(value)>;
                if constexpr (std::is_same_v<T, ScanNode>) {
                    return execute_scan(plan, value, node.output_attrs);
                } else {
                    const JoinNode& join = value;
                    auto left_rows  = eval(join.left);
                    auto right_rows = eval(join.right);
                    std::vector<std::vector<Data>> results;

                    auto merge_records = [&](const std::vector<Data>& lrec,
                                             const std::vector<Data>& rrec) {
                        std::vector<Data> new_record;
                        new_record.reserve(node.output_attrs.size());
                        for (auto [col_idx, _]: node.output_attrs) {
                            if (col_idx < lrec.size()) {
                                new_record.emplace_back(lrec[col_idx]);
                            } else {
                                new_record.emplace_back(rrec[col_idx - lrec.size()]);
                            }
                        }
                        results.emplace_back(std::move(new_record));
                    };

                    const auto build_side = join.build_left ? left_rows : right_rows;
                    const auto probe_side = join.build_left ? right_rows : left_rows;
                    size_t build_col = join.build_left ? join.left_attr : join.right_attr;
                    size_t probe_col = join.build_left ? join.right_attr : join.left_attr;

                    CuckooMapData cmap;
                    cmap.reset(std::max<size_t>(16, build_side.size() * 2 + 1));

                    // build
                    for (size_t i = 0; i < build_side.size(); ++i) {
                        const auto& rec = build_side[i];
                        const Data& key = rec[build_col];
                        if (std::get_if<std::monostate>(&key)) continue; // skip NULL
                        cmap.insert(key, i);
                    }

                    // probe
                    for (size_t j = 0; j < probe_side.size(); ++j) {
                        const auto& prec = probe_side[j];
                        const Data& key = prec[probe_col];
                        if (std::get_if<std::monostate>(&key)) continue;
                        if (auto vec = cmap.find(key)) {
                            for (auto bidx: *vec) {
                                if (join.build_left) {
                                    merge_records(build_side[bidx], probe_side[j]);
                                } else {
                                    merge_records(probe_side[j], build_side[bidx]);
                                }
                            }
                        }
                    }

                    return results;
                }
            },
            node.data);
    };

    auto ret = eval(plan.root);
    auto ret_types = plan.nodes[plan.root].output_attrs
                     | views::transform([](const auto& v) { return std::get<1>(v); })
                     | ranges::to<std::vector<DataType>>();
    Table table{std::move(ret), std::move(ret_types)};
    return table.to_columnar();
}

void* build_context() {
    return nullptr;
}

void destroy_context([[maybe_unused]] void* context) {}

} // namespace Contest